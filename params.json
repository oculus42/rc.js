{
  "name": "Rowcol",
  "tagline": "Row/Column Data Manipulation",
  "body": "[![Build Status](https://travis-ci.org/oculus42/rc.js.svg?branch=master)](https://travis-ci.org/oculus42/rc.js)\r\n[![Code Climate](https://codeclimate.com/github/oculus42/rc.js/badges/gpa.svg)](https://codeclimate.com/github/oculus42/rc.js)\r\n[![Test Coverage](https://codeclimate.com/github/oculus42/rc.js/badges/coverage.svg)](https://codeclimate.com/github/oculus42/rc.js/coverage)\r\n\r\nrowcol.js - Row/Column Data Manipulation\r\n=====\r\n\r\nWhile JSON arrays of objects are very familiar for representing collections of data and map nicely to row-based storage in databases, they are inefficient for transmission, storage, and filtering. \"Rows\" are good for interacting with a specific record, but not for *finding* that record.\r\n\r\n**rowcol.js** provides tools for converting between rows and columns and interacting with columnar data.\r\n\r\nPerformance Comparisons\r\n---\r\n*  [Single Column Filter](http://jsperf.com/rc-simple/5) — For simple single-column comparisons, rowcol was 40-400% faster. With time, this performance has changed. As of December 27, 2015, rowcol is now slower in Chrome and Firefox, while Safari is faster.\r\n*  [Simple Equivalence Filter](http://jsperf.com/rc-equiv/7) — Simple equivalence is an order of magnitude faster than native row filtering, except, strangely, in Firefox (as of December 27, 2015).\r\n*  More to come.\r\n\r\nProblems with Rows\r\n----\r\n*  Each JSON row includes a header (the key in a key-value pair) for each record. For heterogeneous data, rearranging this into columns removes the weight of the header during transmission. Rows with optional keys add `undefined` values, but may still be smaller depending on column counts and names.\r\n*  Many data filters are applied to columns (`price > 50.00` or `active == true`), requiring incrementing across all objects even though you only want one particular attribute.\r\n\r\nBenefits of Columns\r\n----\r\n*  Heterogeneous data is transmitted in a more compact format. Two real-world test objects with complex, multi-level data saw substantial reductions (row/column rotation was performed on multiple levels):\r\n  *  10936 became 7117 characters for a ~35% reduction.\r\n  *  123903 became 90892 characters for a ~27% reduction.\r\n  *  TODO: Synthetic tests and JSPerf examples.\r\n*  Filters return arrays of indexes for easy set manipulation (union, intersection, difference). In fairness you could do this with rows, but it is a requirement of column-oriented filtering\r\n*  Some column filters can be performed with simple comparisons: no filter function overhead.\r\n\r\nProblems with Columns\r\n----\r\n*  There is no native column-based filtering.\r\n*  Columns are inconvenient for interacting with a single record (row).\r\n*  Lack of 3rd-party library support for columns.\r\n\r\n\r\nRowCol Solutions\r\n----\r\n###Filter\r\nThe simple column-based filter supports strict comparison intended for primitive types or a filter function. For all filter actions, the original object is not modified, but complex data types are referenced. Filters are broken into three functions:\r\n*  `rowcol.object.filter(obj, field, filter)` - Basic filter action returns a result set based on a field name and a filter.\r\n*  `rowcol.object.filterIndexes(obj, field, filter)` - Takes the same arguments as `rowcol.object.filter` but returns the indexes of the filter action. This is useful for more complex set manipulation.\r\n*  `rowcol.object.filterMerge(obj, indexes)` - Allows a filter action with an external source of indexes.\r\n\r\n###Proxy\r\nExtracting a row for viewing and interaction is convenient, but changes to primitive types on the \"view\" object will not be reflected on the original column-based store. **Proxy** objects add `.commit()` and `.finalize()` to update the source columns and keep your data consistent. Proxy stores copies and/or references of the information passed when a proxy is created, so you must use the `.destroy()` or `.finalize()` method to avoid memory leaks.\r\n\r\n###Rotate\r\nRowCol provides `rowcol.rotate` to convert arrays of objects (rows) and objects of arrays (columns) back and forth. This allows the compact transmission of columns while existing row-based code. Performance testing is recommended if you are rotating large datasets.\r\n\r\n###RC Chaining\r\nAn object can be made into an `RC` object to support chaining of the following methods:\r\n*  `filter` - Calls `rowcol.object.filter` and provides the result in an RC object for continued chaining.\r\n*  `proxy` - Calls `rowcol.object.proxy` and returns a Proxy object. Ends the chain.\r\n*  `rotate` - Call `rowcol.object.rotate`, converting a column-based object of arrays into a row-based array of objects. Ends the chain.\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}